// 循環選擇
// Uva 21944 Power Crisis
// 類題： Uva 305 Joseph
// https://blog.csdn.net/mobius_strip/article/details/33719959

//約瑟夫環公式 -> f(i) = (f(i-1)+m)%i;
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n;
    while(cin >> n && n){
        // 用loop去找解
        for(int i = 1; i < n; i++){
            int k = 0;
            // 模擬了n-1輪的淘汰過程
            // j 代表還剩下幾個人！
            // 倒過來想的概念 
            /*
                舉例 n = 5, i = 3;
                最後活下來的那個人因為只剩下一個人一定是在0
                -> 往後推假設現在剩下兩個人, 0+3的意義是你透過+3，這樣活下來的一樣還是會是他（因為是每三個被殺一次，反言之假設贏的人的數字加三就不會被殺）, %2讓她編號正確（因為是一個環狀系統）
                    -> 所以是 (0+3) % 2 == 1;
                -> 以此類推剩下三個的時候就變成(1+3) % 3 == 1;
                最後一路往後推，就知道這個i的前提下，最後活著的會是哪個人！
            */
            // 為什麼只需要從=1到<n -> 因為第一個人會先被殺掉
            for(int j = 1; j < n; j++)
                k = (k+i) % j;

            // 為什麼是13 -> 11, 因為首先1號一定要先被關(也就是k == 0) => 13->12 => 然後數字是從0開始數 => 12 -> 11!
            if( k == 11){
                printf("%d\n", i);
                break;
            }
        }
    }
    return 0;
}